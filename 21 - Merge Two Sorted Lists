Pattern : 
--------------------------------

Compare the nodes one by one(with the use of dummy node), and as its already sorted then once any of them reaches the end point(null), then can just put an if-else case outside the loop and make other sorted list directly merged into the other one.

// can use Two pointers for TC 
//  i used the conventional one so could only reach upto 4 ms.(0 ms possible using Two pointers)

Test Cases: 
---------------------------------
list1 || 1 -> 2 -> 4
list2 || 1 -> 3 -> 4

merged/dummy listNode || 1 -> 1 -> 2 -> 3 -> 4 -> 4

Code :
---------------------------------
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(-1);
        ListNode tail = dummy;
        while(list1 != null && list2 !=null){
            if(list1.val <= list2.val){
                tail.next = list1;
                list1 = list1.next;
            }
            else{
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
           
        }
        if(list1 != null){
                tail.next = list1;
            }
            else{
                tail.next = list2;
            }
         return dummy.next;
    }
}
